# Cangaceiro Javascript: Uma aventura no sertão da programação

Projeto com os resultados dos estudos realizados com o livro Cangaceiro Javascript de Flávio Almeida.

## O Livro: Partes / Capítulos / Conteúdo

### Parte 1 - O caminho do cangaceiro

- [x] Cap 1 - Prólogo: era uma vez no sertão
- [x] Cap 2 - Negociar com o cangaceiro, tem coragem?
- [x] Cap 3 - No cangaço, é ação para todo lado
- [x] Cap 4 - Dois pesos, duas medidas?
    - [x] 4.1 - Isolando a responsabilidade de conversão de datas
    - [x] 4.2 - Métodos estáticos
        - Métodos estáticos podem ser chamados diretamente da classe na qual foram declarados sem a necessidade de instanciar a classe.
    - [x] 4.3 - Template literal
        - Template literal (ES6): nova forma de concatenar strings que evita processo de concatenação.
    - [x] 4.4 - A boa prática do fail-fast
        - fail-fast: boa prática de validar os parâmetros recebidos antes de utilizá-los na lógica da aplicação.
- [x] Cap 5 - O bando deve seguir uma regra
    - [x] 5.1 - Criando um novo modelo
    - [x] 5.2 - O tendão de Aquiles do Javascript
        - O tendão de aquiles do JS é a dependência entre scripts
    - [x] 5.3 - Blindando o nosso modelo
- [x] Cap 6 - A moda no cangaço
    - [x] 6.1 - O papel da View
    - [x] 6.2 - Nossa solução de View
    - [x] 6.3 - Construindo um template dinâmico
    - [x] 6.4 - Totalizando o volume de negociações
    - [x] 6.5 - Totalizando com reduce
- [x] Cap 7 - O plano
    - [x] 7.1 - Parâmetro default
    - [x] 7.2 - Criando a classe MensagemView
    - [x] 7.3 - Herança e reutilização de código
    - [x] 7.4 - Classes abstratas?
    - [x] 7.5 - Para saber mais: super
    - [x] 7.6 - Adquirindo um novo hábito com const

### Parte 2 - Força Volante

- [ ] Cap 8 - Um cangaceiro sabe delegar tarefas
    - [x] 8.1 - E se atualizarmos a View quando o modelo for alterado?
    - [x] 8.2 - Driblando o this dinâmico
    - [ ] 8.3 - Arrow function e seu escopo léxico
- [ ] Cap 9 - Enganaram o cangaceiro, será?
    - [ ] 9.1 O padrão de projeto Proxy
    - [ ] 9.2 - Aprendendo a trabalhar com Proxy
    - [ ] 9.3 - Construindo armadilhas de leitura
    - [ ] 9.4 - Construindo armadilhas de escrita
    - [ ] 9.5 - Reflect API
    - [ ] 9.6 - Um problema não esperado
    - [ ] 9.7 - Construindo armadilhas para métodos
    - [ ] 9.8 - Uma pitada do ES2016 (ES7)
    - [ ] 9.9 - Aplicando a solução em NegociacaoController
- [ ] Cap 10 - Cúmplice na emboscada
    - [ ] 10.1 - O padrão de projeto Factory
    - [ ] 10.2 - Nosso proxy ainda não está 100%!
    - [ ] 10.3 - Associando modelo e View através da classe Bind
    - [ ] 10.4 - Parâmetros REST
- [ ] Cap 11 - Data dos infernos!
    - [ ] 11.1 - O problema com o input date
    - [ ] 11.2 - Ajustando nosso converter
    - [ ] 11.3 - Lidando com exceções
    - [ ] 11.4 - Criando nossa própria exceção: primeira tentativa
    - [ ] 11.5 - Criando nossa própria exceção: segunda tentativa
- [ ] Cap 12 - Pilhando o que interessa!
    - [ ] 12.1 - Servidor e infraestrutura
    - [ ] 12.2 - Requisições Ajax com o objeto XMLHttpRequest
    - [ ] 12.3 - Realizando o parse da resposta
    - [ ] 12.4 - Separando responsabilidades
- [ ] Cap 13 - Lutando até o fim
    - [ ] 13.1 - Callback HELL
    - [ ] 13.2 - O padrão de projeto Promise
    - [ ] 13.3 - Criando Promises
    - [ ] 13.4 - Criando um serviço para isolar a complexidade do XMLHttpRequest
    - [ ] 13.5 - Resolvendo Promises sequencialmente
    - [ ] 13.6 - Resolvendo Promises paralelamente
    - [ ] 13.7 - Ordenando o período
    - [ ] 13.8 - Impedindo importações duplicadas
    - [ ] 13.9 - As funções filter() e some()

### Parte 3 - A revelação

- [ ] Cap 14 - A algibeira está furada!
- [ ] Cap 15 - Colocando a casa em ordem
- [ ] Cap 16 - Entrando na linha
- [ ] Cap 17 - Dividir para conquistar
- [ ] Cap 18 - Indo além
- [ ] Cap 19 - Chegando ao limite
- [ ] Cap 20 - Enfrentamento final
